#-------------------
# parallel transfer thread pooling behavior - work-in-progress
#-------------------

# set to true to use a transfer thread pool, or false to use the old algorithm
#  NOTE: the use of this pool is still experimental, use with caution!!!!!
transfer.use.pool=false
# maximum pool size for transfer threads, expressed as the number of simultaneous parallel transfers.  This will be multiplied by the 
# transfer.max.parallel.threads value to arrive at a pool size
transfer.executor.pool.max.simultaneous.transfers=2
# timeout for threads in the transfer pool in millis
transfer.executor.pool.timeout=60000
# interim patch code to correct parallel transfer cap behavior
# length in mb
transfer.send.max.threads.threshold=33554432

#------------------
# i/o pipeline tuning - work in progress.  See wiki at https://code.renci.org/gf/project/jargon/wiki/?pagename=Networking+and+Optimization
#------------------

# buffer sized used in parallel get/put threads FIXME needs impl to replace constant, currently no effect
transfer.parallel.buffer.size=2048
# time out (in seconds) for iRODS connections to the main control channel (typicall 1247)
socket.timeout=0
# time out (in seconds) for socket connections for parallel transfer threads
parallel.socket.timeout=0
# internal buffer size used for the input stream between Jargon and iRODS  (0 = use defaults, -1 = do not wrap with buffered input stream)
jargon.io.internal.input.stream.buffer.size=0
# internal buffer size used for the output stream between Jargon and iRODS  (0 = use defaults, -1 = do not wrap with buffered output stream)
jargon.io.internal.output.stream.buffer.size=-1
#  Get the size of the internal buffer cache used to accumulate data being sent to iRODS.   (0 =  do not utilize the cache buffer)
jargon.io.internal.cache.buffer.size=65535
# buffer size used for the input stream being sent to iRODS. (0 = use defaults, -1 = do not wrap with buffered input stream)
jargon.io.send.input.stream.buffer.size=0
#  size of the buffer used in read/write operations (read into, and write from this buffer in the read/write loop).
jargon.io.input.to.output.copy.byte.buffer.size=8192
# size of buffer used in output stream to a local file  (0 = use defaults, -1 = do not wrap with buffered input stream)
jargon.io.local.output.stream.buffer.size=0
# size of buffer used in put operations (file segment size per call to DataObjInp)
jargon.put.buffer.size=4194304
# size of buffer used in get operations (file segment size per call to DataObjInp)
jargon.get.buffer.size=4194304

#------------------
#max query results tuning 
#------------------

max.files.and.dirs.query.max=5000

#-----------------
# Misc transfer behaviors
#-----------------

#allow resource redirects (redirect transfers to resource server containing file)
transfer.allow.redirects=false
#compute a checksum for every file put to iRODS (does not do a verification/comparison)
transfer.compute.checksum=false
#compute a checksum for every file put/get to iRODS and verify
transfer.computeandvalidate.checksum=false
#send within-file status call-backs on transfers (slight performance penalty, but allows monitoring of file progress if 'true'
transfer.intra.file.callbacks=false
#do not allow parallel tranfsers at all - not yet implemented
transfer.use.parallel=true
#thread cap for parallel transfers, can ineract with pool settings above
transfer.max.parallel.threads=4
# UDP not currently supported
transfer.use.udp=false

