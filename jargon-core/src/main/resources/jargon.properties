encoding=UTF-8

# tcp ip socket prefs primary connection

primaryTcpKeepAlive=true
primaryTcpSendWindowSize=0
primaryTcpReceiveWindowSize=0
primaryTcpPrefs.connectionTime=1
primaryTcpPrefs.bandwidth=1
primaryTcpPrefs.latency=0
pam.time.to.live.in.seconds=0
#-------------------
# parallel transfer thread pooling behavior - work-in-progress
#-------------------

# set to true to use a transfer thread pool, or false to use the old algorithm
#  NOTE: the use of this pool is still experimental, use with caution!!!!!
transfer.use.pool=false
# maximum pool size for transfer threads, expressed as the number of simultaneous parallel transfers.  This will be multiplied by the 
# transfer.max.parallel.threads value to arrive at a pool size
transfer.executor.pool.max.simultaneous.transfers=2
# timeout for threads in the transfer pool in millis
transfer.executor.pool.timeout=60000
# interim patch code to correct parallel transfer cap behavior
# length in mb
transfer.send.max.threads.threshold=33554432

# time out (in seconds) for iRODS connections to the main control channel (typicall 1247)
socket.timeout=0
# time out (in seconds) for socket connections for parallel transfer threads
parallel.socket.timeout=120
# renewal period in seconds (0 to turn off) that is consulted during recursive transfers to 
# restart the agent connection.
socket.renewal.interval.in.seconds=420
# internal buffer size used for the input stream between Jargon and iRODS  (0 = use defaults, -1 = do not wrap with buffered input stream)
jargon.io.internal.input.stream.buffer.size=0
# internal buffer size used for the output stream between Jargon and iRODS  (0 = use defaults, -1 = do not wrap with buffered output stream)
jargon.io.internal.output.stream.buffer.size=0
#  Get the size of the internal buffer cache used to accumulate data being sent to iRODS.   (0 =  do not utilize the cache buffer)
jargon.io.internal.cache.buffer.size=-1
# buffer size used for the input stream being sent to iRODS. (0 = use defaults, -1 = do not wrap with buffered input stream)
jargon.io.send.input.stream.buffer.size=0
#  size of the buffer used in read/write operations (read into, and write from this buffer in the read/write loop).
jargon.io.input.to.output.copy.byte.buffer.size=1048576
# size of buffer used in output stream to a local file  (0 = use defaults, -1 = do not wrap with buffered output stream)
jargon.io.local.output.stream.buffer.size=0
# size of buffer used in input stream from a local file  (0 = use defaults, -1 = do not wrap with buffered input stream)
jargon.io.local.input.stream.buffer.size=0
# size of buffer used in put operations (file segment size per call to DataObjInp)
jargon.put.buffer.size=4194304
# size of buffer used in get operations (file segment size per call to DataObjInp)
jargon.get.buffer.size=4194304
# size of buffer used in parallel transfers as the copy byte buffer size
jargon.parallel.copy.buffer.size=4194304
# enables reconnect option sent in startup pack and used in connection handling (as in the -T icommand option (work in progress)
jargon.reconnect=false
# if jargon.reconnect is true, this is the time in milliseconds before restarting, default is 10 minutes
jargon.reconnect.time.in.millis=600
# turns on detailed instrumentation code which will be reported in the perf4j log as defined in log4j.xml. Production of this data will be implemented over time
jargon.instrument=false

#------------------
#max query results tuning 
#------------------
max.files.and.dirs.query.max=5000

#-----------------
# Misc transfer behaviors
#-----------------

#allow resource redirects (redirect transfers to resource server containing file)
transfer.allow.redirects=false
#compute a checksum for every file put to iRODS (does not do a verification/comparison)
transfer.compute.checksum=false
#compute a checksum for every file put/get to iRODS and verify
transfer.computeandvalidate.checksum=false
#send within-file status call-backs on transfers (slight performance penalty, but allows monitoring of file progress if 'true'
transfer.intra.file.callbacks=false
#do not allow parallel transfers at all
transfer.use.parallel=true
#use NIO variant for parallel transfers (use java nio transferTo between the local file system and iRODS) - EXPERIMENTAL
transfer.use.nio.for.parallel=false
#thread cap for parallel transfers, can interact with pool settings above, set to 0 for no max, transfer.use.parallel overrides this
transfer.max.parallel.threads=8
# UDP not currently supported
transfer.use.udp=false
# use DEFAULT, MD5, or SHA256 checksums, DEFAULT will equal to MD5
transfer.checksum.algorithm=DEFAULT
# long file restart behavior
transfer.long.file.restart=false



#------------------------
# tcp ip socket prefs primary connection

parallelTcpKeepAlive=true
parallelTcpSendWindowSize=16384
parallelTcpReceiveWindowSize=16384
parallelTcpPrefs.connectionTime=0
parallelTcpPrefs.bandwidth=1
parallelTcpPrefs.latency=0

#---------------
# properties controlling general behaviors
#=--------------

connection.factory=tcp

#if i cannot browse under root, attempt to find the /zone/home/public subdirectory and the user home directory
default.to.public.if.nothing.under.root.when.listing=true

# use a cache of discovered server properties to remember if iRODS has certain facilities available, instead
# of repeatedly asking iRODS or invoking methods that depend on certain conditions.  This avoids those 
# repeated calls
use.discovered.server.properties.cache=true

# use specific query for CollectionAndDataObjectListAndSearchAO collection listings that return permissions
# this will fall back to GenQuery if specific query is not supported
use.specific.query.for.collection.listings=true

# Indicates whether a specific query (listUserACLForDataObjViaGroup) is available and can be used to
# check the user access rights for a user who has access via a group.  This is so methods like <code>IRODSFile.canRead()</code> will work
#  even though a user does not have explicit permissions, and is a member of a group that has access instead.
use.specquery.for.dataobj.permissions.for.user.in.group=true

# force flushes when doing PAM auth.  This is to allow PAM to work with versions prior to iRODS 3.3, where the additional flushes
# were required.  These additional flushes cause performance issues and should not be used with iRODS 3.3
# consider this flag deprecated...it can be used still for problem diagnosis, but with the best thing to do is upgrade iRODS.  For
# irods 4.0.x until irods 4.1.0, there is a potential issue with PAM seeming to hang, as noted in
# https://github.com/DICE-UNC/jargon/issues/70, but that should no longer require this flag
force.pam.flush=false
